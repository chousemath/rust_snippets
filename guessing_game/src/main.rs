/*
    General Notes
    - a crate is a package of Rust code
*/

// lets Rust know that we will be using these external dependencies
// automatically calls `use rand;`
extern crate rand;

// bring the input/output library (from the standard library) into scope
use std::io;
// Ordering is an enum (like Result), and it has values Less, Greater, or Equal
use std::cmp::Ordering;
// Rng is a trait that defines methods that random number generators implement
use rand::Rng;

// the main function is the entry point of the program
fn main() {
    println!("\x1b[31;1mWelcome to the number guessing game!\x1b[0m");
    println!("We are going to have so much \x1b[33;1mfun\x1b[0m ^^");

    // thread_rng provides a random number local to this thread, generated by OS
    // gen_range takes two numbers, provides a random number between them (lower incl, upper excl)
    // here we are doing variable binding, the type of the variable in this case is inferred
    // in Rust, variables bound by `let` are immutable by default, need `let mut` for mutability
    // can actually `rebind` variables: let x = 1; let x = "yo"; Rust will take the latest binding
    // Rust will default to i32
    let secret_number = rand::thread_rng().gen_range(1, 101);
    // println!("Pssssst...the secret number is \x1b[33;1m{}\x1b[0m", secret_number);

    loop {
        // ask user for input
        println!("\x1b[36;1mPlease input a number between 1 and 100!\x1b[0m");

        // process that input
        // the let statement is used to create a new variable
        // variables are mutable by default, `mut` allows variable to mutate
        // String::new() returns a new instance of a String (standard library)
        // :: indicates that new is an associated function of the String type (static method)
        // the new instance of String is an empty string
        let mut guess = String::new();

        // call the associated function stdin() on the io library
        // argument of read_line must be mutable to accept user input
        // references are immutable by default, therefore &mut is required
        // read_line returns io::Result (an enumeration, variants: Ok, Err), encodes error reports
        // the way it is set up now, Rust will crash the program if there is an Err
        io::stdin().read_line(&mut guess).expect("Failed to read line...");

        // here, we shadow the value of `guess` with a new one
        // this allows us to reuse variable names we already have rather than creating new ones
        // trim() eliminates any whitespaces at the beginning or end of the string
        // trim required because user must press `enter` key for read_line, and that adds a whitespace
        // parse() gets the target parse type from the type assignment of `guess` (u32)
        // Rust will also infer that the type of secret_guess is u32
        // parse() returns a Result type, allowing for error handling
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(e) => {
                println!("\x1b[31;1m{}\x1b[0m", e);
                println!("Please try again");
                continue;
            }
        };

        // {} is a placeholder that holds a value in place
        println!("\x1b[33;1mYou just entered:\x1b[0m \x1b[36;1m{}\x1b[0m", guess);

        // check that the input is in the expected form
        // cmp compares two values that can be compared, and returns an Ordering
        match guess.cmp(&secret_number) {
            Ordering::Less    => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal   => {
                println!("You win!");
                break;
            }
        }
    }
}
